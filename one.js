/** * Created by hoss on 3/2/2016. */// using Either and chain for composable error handling and comparison with imperative codevar Right = x => ({    map:f=> Right(f(x)),    //fold removes the value from the type when    // function is run, it will drop out of the container type    // and return our value back.    // fold:f=>f(x),    //however in instances where we do now know if    // we are using right or left we need to handel two instances    // because of this of this our function will take two arguments.    // this allows for pure function error handling code branching and "null checks", capture, disjunction, and OR    fold:(f,g)=>g(x),    inspect :() => `Right(${x})`})var Left =x => ({    //will not run f on x, it will ignore the f    map:f=> Left(x),    fold:(f,g)=>f(x),    inspect :() => `Left(${x})`})// will run if left return error and if right return valueconst resultR = Right(2).map(x=>x+1).map(x=> x/2).fold(x=>'error', x=>x);console.log(resultR);// when we run left it will ignore all requests and dump out errorconst resultL = Left(2).map(x=>x+1).map(x=> x/2).fold(x=> 'error', x=>x);console.log(resultL);const FindColor = name => ({    red:'#ff4444', blue:'#3b5998', yellow:'#fff68f'})[name]const resultF= FindColor('red');console.log(resultF);const resultFSU= FindColor('red').slice(1).toUpperCase()console.log(resultFSU);//no color and slice will return undefined and reason is no string result// is ever returned back.//const resultFSUNC= FindColor('green').slice(1).toUpperCase()//console.log(resultFSUNC);const FindColorWithHandel= name => {    const found = ({red:'#ff4444', blue:'#3b5998', yellow:'#fff68f'})[name]    return  found ? Right(found):Left(null)}//findColorWithHandle does not return a string it returns an either// with either type cannot call string on it.// const resultFCWH= FindColorWithHandel('green').slice(1).toUpperCase()// we will need to map over it.const resultFCWH= FindColorWithHandel('blue')    .map(c=> c.slice(1))    //finish call with fold if error return error and if no error call method    .fold(e=>'no color',        c=> c.toUpperCase())console.log(resultFCWH);// resutFCWH will tell whether or not it will return a null// it is for this reason you must pass a map and avoid being// avoid blind sided at run time. Because if the value is not found// map will not run .// However FindColorWithHandel now has multiple expressions.// to solve this problem we need to return the value consistently// in order to make the code safer and more predictable    const fromNullable = x =>    // if found put into the right and if not goes into the left    x !=null ? Right(x) : Left(null);// now expression can be written in one goconst  FindColorUNallable = name =>fromNullable({red:'#ff4444', blue:'#3b5998', yellow:'#fff68f'}[name])const resultNallable= FindColorUNallable('purpel')    .map(c=>c.slice(1))    .fold(e=> 'no color',          c=>c.toUpperCase());console.log(resultNallable);const fs = require('fs');const getPort= () =>{    try{        const str = fs.readFileSync('config.json')        const config = JSON.parse(str)        return config.port    }catch(e){        return 3000    }}//if returned will if know if right or left don't need to check if it is an error or not// since it is compose-able type will return right result when mapped and foldedconst tryCatch = f =>{    try{        return Right(f())    }catch(e){        return Left(e)    }}const resultPort = getPort()console.log(resultPort);const getPortTryCatch= () =>     tryCatch(() => fs.readFileSync('confi.json')) // Right('')    //if success will run map         .map(c=> JSON.parse(c) ) // Right(Left(e)) || Right(Right('')         .fold(e=>3000,         c=> c.port )const resultPortCatch= getPortTryCatch();console.log(resultPortCatch);//with getPortTryCatch result will explode if there is no config.json// and will read unexpected end of JSON input// define new chain method on objectvar Right = x => ({    map:f=> Right(f(x)),    // chain expects you to run a function and return another   chain:f=>f(x),    // fold is removing a value from it's context,    // taking it out of the box whether it is a Right, Left    // or a box itself    fold:(f,g)=>g(x),    inspect :() => `Right(${x})`})var Left =x => ({    map:f=> Left(x),    //left ignores everything    chain: f=>Left(x),    fold:(f,g)=>f(x),    inspect :() => `Left(${x})`});const getPortTryCatchChain= () =>    tryCatch(() => fs.readFileSync('config.json')) // Right('')    //if success will run map        .chain(c=> tryCatch(() => JSON.parse(c))) // Right(Left(e)) || Right(Right('')        .fold(e=>3000,            c => c.port);const resultPortCatchChain= getPortTryCatchChain();console.log(resultPortCatchChain);// are chaining and folding the same thing?//they are two very different function although// they may have the same definition sometimes.//1. chain expects you to run a function and return another//2. fold is removing a value from it's context,// taking it out of the box whether it is a Right, Left// or a box itself// imperative code compared to equivalent composed expressions usingconst openSite =() => {    if(current_user) {        return renderPage(current_user)    }else{        return showLogin()    }}const openSite = () =>    fromNullable(current_user)    .fold(showLogin,renderPage)const getPrefs = user => {    if(user.premium){        return loadPrefs(user.preferences)    }else{        return defaultPrefs    }}const getPrefs = user => (user.premium ? Right(user) : Left('not premium')).map(u => u.preferences).fold(()=> defaultPrefs, prefs => loadPrefs(prefs))const streetName = user => {    const address = user.address    if(address){        const street = address.street        if(street){            return street.name        }    }    return 'no street'}const streetName = user =>fromNullable(user.address)    .cahin(a=> fromNullable(a.street))    .map(s=> s.name)    .fold(e=> 'no street', n => n)const concatUniq = (x, ys) => {    const ofound = ys.filter(y=> y=== x)[0]    return found ? ys : ys.concat(x)}const concatUniq = (x, ys) =>fromNullable(ys.filter(y=> y=== x)[0]).fold(()=> ys.concat(x), y => ys)const wrapExamples = example=> {    if(example.previewPath){        try{            exmple.preview =  fs.readFileSync(example.previewPath)        }catch(e){}    }    return example}const readFile = x => tryCatch(()=> fs.readFileSync(x))const wrapExample = example =>fromNullable(example.previewPath).chain(readFile).fold(()=> example,ex=> Object.assign({preview:p}, ex));const parseDbUrl = cfg => {    try{        const  c= JSON.parse(cfg)        if(c.url){            return c.url.match(/postgress:\/\/([^:]+):([^@]+)@([^:]+):(\d+)\/(.+)/)        }    }}const parseDbUrl  = cfg=>tryCatch(() => JSON.parse(cfg)).chain(c=> formNullable(c.url)).fold(e=> null,u => u.match(/postgress:\/\/([^:]+):([^@]+)@([^:]+):(\d+)\/(.+)/))